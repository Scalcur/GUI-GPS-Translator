/*=======================================================
//
//      Authors:    Kosorotova Valeria
//                  Pasechnikov Vyacheslav
//
//      15/8/2021
//
//=======================================================*/

#include "algorithm.h"

//массивы для координат в различных СК
double GK42[3] = {0};
double SK42_R[3] = {0};
double PZ_90_11[3] = {0};

double PZ_90_11_R[3] = {0};

//дополнительные параметры
int A_GK42;
double Alpha_GK42;
double E_GK42;
double N_GK42;

int A_PZ;
double Alpha_PZ;
double E_PZ;
double N_PZ;

double dopusk_GK = 0.0001;

//=========================================================================================================================
//---------------------------------------------------БЛОК ПЕРЕВОДА В ПЗ-90.11----------------------------------------------
//=========================================================================================================================

void from_SK42_GK_to_PZ_90_11(double X_GK42, double Y_GK42, double H_GK42)
{
    from_42GK_to_42(X_GK42, Y_GK42, H_GK42);

    //расчет параметров квадрата эксцентриситета Е, сжатия элипсоида α и большей полуоси а
    A_GK42 = 6378245;
    Alpha_GK42 = (1 / 298.3);
    E_GK42 = (2 * Alpha_GK42 - pow(Alpha_GK42, 2));
    N_GK42 = (A_GK42)/(sqrt(1 - E_GK42 * pow(sin(GK42[0]),2)));

    for(uint8_t i = 0; i<3; i++)
    {
        SK42_R[i] = 0;
    }

    //Расчет прямоугольных координат СК-42
    SK42_R[0] = (N_GK42 + GK42[2]) * cos(GK42[0]) * cos(GK42[1]);
    SK42_R[1] = (N_GK42 + GK42[2]) * sin(GK42[1]) * cos(GK42[0]);
    SK42_R[2] = ((1 - E_GK42)*N_GK42 + GK42[2])*sin(GK42[0]);

    from_SK42_R_to_PZ_90_11(SK42_R[0], SK42_R[1], SK42_R[2]);
}

// Получение геодезических координат СК-42
void from_42GK_to_42(double X, double Y, double H)
{   
    for(uint8_t i = 0; i<3; i++)
    {
        GK42[i] = 0;
    }

    int n = trunc((Y * pow(10, -6)));

    double beta = (X / 6367558.4968);

    double B0 = beta + sin(2 * beta) * (0.00252588685 - 0.00001491860 * pow(sin(beta), 2) + 0.00000011904 * pow(sin(beta), 4));

    double z0 = ((Y - (10 * n + 5)*pow(10, 5))/(6378245 * cos(B0)));

    double dB = -pow(z0, 2) * sin(2*B0) * (0.251684631 - 0.003369263 * pow(sin(B0),2) + 0.00001127 * pow(sin(B0),4)\
    - pow(z0, 2)*(0.10500614 - 0.04559916 * pow(sin(B0),2) + 0.00228901 * pow(sin(B0),4) - 0.00002987 * pow(sin(B0),6)\
    - pow(z0, 2)*(0.042858 - 0.025318 * pow(sin(B0),2) + 0.014346 * pow(sin(B0),4) - 0.001264 * pow(sin(B0),6)\
    - pow(z0, 2)*(0.01672 - 0.00630 * pow(sin(B0),2) + 0.01188 * pow(sin(B0),4) - 0.00328 * pow(sin(B0),6)))));

    double l = z0 * (1 - 0.0033467108 * pow(sin(B0),2) - 0.0000056002 * pow(sin(B0),4) - 0.0000000187 * pow(sin(B0),6)\
    - pow(z0, 2)*(0.16778975 + 0.16273586 * pow(sin(B0),2) - 0.00052490 * pow(sin(B0),4) - 0.00000846 * pow(sin(B0),6)\
    - pow(z0, 2)*(0.0420025 + 0.1487407 * pow(sin(B0),2) + 0.0059420 * pow(sin(B0),4) - 0.0000150 * pow(sin(B0),6)\
    - pow(z0, 2)*(0.01225 + 0.09477 * pow(sin(B0),2) + 0.03282 * pow(sin(B0),4) - 0.00034 * pow(sin(B0),6)\
    - pow(z0, 2)*(0.0038 + 0.0524 * pow(sin(B0),2) + 0.0482 * pow(sin(B0),4) - 0.0032 * pow(sin(B0),6))))));

    GK42[0] = B0 + dB;
    GK42[1] = (6*(n - 0.5)/(57.29577951)) + l;
    GK42[2] = H;

}

//Перевод в ПЗ-90.11
void from_SK42_R_to_PZ_90_11(double X, double Y, double Z)
{
    double GOST_Array[3][3] = {{1, (-3.850439*pow(10, -6)), (1.679685*pow(10, -6))},\
                               {(3.850439*pow(10, -6)), 1, (-1.115071 * pow(10, -8))},\
                               {(-1.679685*pow(10, -6)), (1.115071 * pow(10, -8)), 1}};

    for(uint8_t i = 0; i<3; i++)
    {
        PZ_90_11[i] = 0;
    }
    
    for(uint8_t i = 0; i<3; i++)
    {
        for(uint8_t j = 0; j<3; j++)
        {
            GOST_Array[i][j] = GOST_Array[i][j] * (1 + (-0.228) * pow(10, -6));
        }
    }

    PZ_90_11[0] = (GOST_Array[0][0] * SK42_R[0] + GOST_Array[0][1] * SK42_R[1] + GOST_Array[0][2] * SK42_R[2]) + 23.557;
    PZ_90_11[1] = (GOST_Array[1][0] * SK42_R[0] + GOST_Array[1][1] * SK42_R[1] + GOST_Array[1][2] * SK42_R[2]) + (-140.844);
    PZ_90_11[2] = (GOST_Array[2][0] * SK42_R[0] + GOST_Array[2][1] * SK42_R[1] + GOST_Array[2][2] * SK42_R[2]) + (-79.778);

}

//=========================================================================================================================
//----------------------------------------------КОНЕЦ БЛОКА ПЕРЕВОДА В ПЗ-90.11--------------------------------------------
//=========================================================================================================================

//=========================================================================================================================
//-------------------------------------------------БЛОК ПЕРЕВОДА В СК-42 ГК------------------------------------------------
//=========================================================================================================================

void from_PZ_90_11_to_SK42_GK(double B_PZ_90_11, double L_PZ_90_11, double H_PZ_90_11)
{
    //радианные представления
    B_PZ_90_11 = B_PZ_90_11 * (M_PI/180);
    L_PZ_90_11 = L_PZ_90_11 * (M_PI/180);

    //Расчет доп. параметров
    A_PZ = 6378136;
    Alpha_PZ = (1 / 298.25784);
    E_PZ = (2*Alpha_PZ - pow(Alpha_PZ, 2));
    N_PZ = (A_PZ)/(sqrt(1 - E_PZ * pow(sin(B_PZ_90_11), 2)));

    //Расчет прямоугольных координат ПЗ-90.11
    PZ_90_11_R[0] = (N_PZ + H_PZ_90_11)*cos(B_PZ_90_11)*cos(L_PZ_90_11);
    PZ_90_11_R[1] = (N_PZ + H_PZ_90_11)*sin(L_PZ_90_11)*cos(B_PZ_90_11);
    PZ_90_11_R[2] = ((1 - E_PZ)*N_PZ + H_PZ_90_11)*sin(B_PZ_90_11);

    
    from_PZ_90_11_R_to_SK42(PZ_90_11_R[0], PZ_90_11_R[1], PZ_90_11_R[2]);
    
    A_GK42 = 6378245;
    Alpha_GK42 = (1 / 298.3);
    E_GK42 = (2 * Alpha_GK42 - pow(Alpha_GK42, 2));

    from_Rect_to_Geod(SK42_R[0],SK42_R[1], SK42_R[2], A_GK42, E_GK42, dopusk_GK);

    from_42_to_42GK(GK42[0], GK42[1]);
}

//Перевод в СК-42
void from_PZ_90_11_R_to_SK42(double X, double Y, double Z)
{
    double GOST_Array[3][3] = {{1, (3.850439*pow(10, -6)), (-1.679685*pow(10, -6))},\
                               {(-3.850439*pow(10, -6)), 1, (1.115071 * pow(10, -8))},\
                               {(1.679685*pow(10, -6)), (-1.115071 * pow(10, -8)), 1}};

    for(uint8_t i = 0; i<3; i++)
    {
        SK42_R[i] = 0;
    }
    
    for(uint8_t i = 0; i<3; i++)
    {
        for(uint8_t j = 0; j<3; j++)
        {
            GOST_Array[i][j] = GOST_Array[i][j] * (1 - (-0.228) * pow(10, -6));
        }
    }

    SK42_R[0] = (GOST_Array[0][0] * PZ_90_11_R[0] + GOST_Array[0][1] * PZ_90_11_R[1] + GOST_Array[0][2] * PZ_90_11_R[2]) - 23.557;
    SK42_R[1] = (GOST_Array[1][0] * PZ_90_11_R[0] + GOST_Array[1][1] * PZ_90_11_R[1] + GOST_Array[1][2] * PZ_90_11_R[2]) - (-140.844);
    SK42_R[2] = (GOST_Array[2][0] * PZ_90_11_R[0] + GOST_Array[2][1] * PZ_90_11_R[1] + GOST_Array[2][2] * PZ_90_11_R[2]) - (-79.778);

}

void from_Rect_to_Geod(double X, double Y, double Z, int a, double E, double dopusk)
{
    double D = sqrt((pow(X, 2) + pow(Y, 2)));

    /*printf("D %.9f \n", D);
    printf("X %.9f \n", X);
    printf("Y %.9f \n", Y);
    printf("Z %.9f \n", Z);*/

    double La = asin((Y / D));

    if(D == 0)
    {
        GK42[0] = ((M_PI / 2) * (Z / fabs(Z)));
        GK42[1] = 0;
        GK42[2] = (Z * sin(GK42[0]) - (a * sqrt(1 - E * pow(sin(GK42[0]),2))));
    }

    if(D != 0)
    {
        if((Y < 0) && (X > 0)){GK42[1] = M_PI*2 - La;}

        if((Y < 0) && (X < 0)){GK42[1] = M_PI + La;}

        if((Y > 0) && (X < 0)){GK42[1] = M_PI - La;}

        if((Y > 0) && (X > 0)){GK42[1] = La;}

        if((Y == 0) && (X > 0)){GK42[1] = 0;}

        if((Y == 0) && (X < 0)){GK42[1] = M_PI;}
    }

    if(Z == 0)
    {
        GK42[0] = 0;
        GK42[2] = D - a;
    }
   
    if (Z != 0)
    {
        double r = sqrt((pow(X, 2) + pow(Y, 2) + pow(Z, 2)));
        double c = asin(Z / r);
        double p = (E * a)/(2 * r);
        double s1 = 0;
        double s2, d = 0;
        double b = c + s1;
        
        while (1)
        {
           b = c + s1;
           s2 = asin((p * sin(2*b)) / sqrt(1 - E * pow(sin(GK42[0]),2)));
           d = fabs(s2 - s1);

           if(d < dopusk)
           {
               GK42[0] = b;
               GK42[2] = (D * cos(GK42[0])) + (Z * sin(GK42[0])) - (a * sqrt(1 - E * pow(sin(GK42[0]),2)));
               break;
           }
           else
           {
               s1 = s2;
           }
        }
        
    }

    GK42[1] = GK42[1] * (180/M_PI);
}

void from_42_to_42GK(double B, double L)
{
    int n = trunc((6 + L)/6);

    double l = ((L - (3 + 6 * (n - 1))) / 57.29577951);

    // X
    GK42[0] = 6367558.4968 * B - sin(2*B) * (16002.8900 + 66.9607 * pow(sin(B),2) + 0.3515 * pow(sin(B),4)\
    - pow(l,2) * (1594561.25 + 5336.535 * pow(sin(B),2) + 26.790 * pow(sin(B),4) + 0.149 * pow(sin(B),6)\
    + pow(l,2) * (672483.4 - 811219.9 * pow(sin(B),2) + 5420.0 * pow(sin(B),4) - 10.6 * pow(sin(B),6)\
    + pow(l,2) * (278194 - 830174 * pow(sin(B),2) + 572434 * pow(sin(B),4) - 16010 * pow(sin(B),6)\
    + pow(l,2) * (109500 - 574700 * pow(sin(B),2) + 863700 * pow(sin(B),4) - 398600 * pow(sin(B),6))))));

    // Y
    GK42[1] = (5 + 10*n)*pow(10,5) + l * cos(B) * (6378245 + 21346.1415 * pow(sin(B),2) + 107.1590 * pow(sin(B),4) + 0.5977 * pow(sin(B),6)\
    + pow(l,2) * (1070204.16 - 2136826.66 * pow(sin(B),2) + 17.98 * pow(sin(B),4) - 11.99 * pow(sin(B),6)\
    + pow(l,2) * (270806 - 1523417 * pow(sin(B),2) + 1327645 * pow(sin(B),4) - 21701 * pow(sin(B),6)\
    + pow(l,2) * (79690 - 866190 * pow(sin(B),2) + 1730360 * pow(sin(B),4) - 945460 * pow(sin(B),6)))));

}